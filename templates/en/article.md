I am a big fan of {language1} and one of its early adopters, having been disappointed with the utter failures of {language0}. I have been an avid contributor to many open source projects such as {project_names}. However, after using {language1} for over 5 years, I have been dealing with minor technical flaws. At first, I ignored and even tolerated these flaws, but ultimately, I was forced to confront reality. I could not live with these flaws, and since {language1} is a mature language, it will be difficult, if not impossible, to actually fix these flaws.

I also resented the opinions that {language1} took. When I first used those languages, I thought those opinions were a fresh breath of air. I would constantly defend those opinions on Hacker News, because I thought that these opinions would promote good coding practices and would ulitmately lead to higher productivity. After 5 years of coding though, I realized that those opinions may have been slightly flawed.

And then, I heard of {language2}. {language2} promised to fix all the technical flaws in {language1}. I also read about the opinions inherent in {language2}, and realized that those opinions were utterly correct, compared to the fallicious and wrong-headed opinions in {language1}. And that’s why I switched languages.

Let me show you an example to prove my point.

Here is an example of a “Hello World” program in {language1}:

```{language1}

{language1_hello_world}
```

You can see why I was drawn to this language. Its syntatic sugar was beautiful. But it was ultimately too magical. I didn’t know what was actually going on. What did Format mean? Or Write? When I had to scale up my program, I would be cursing all night trying to debug the latest ‘magic’ that {language1} decided to invoke on me. Half the time, I would be fighting against {language1}’s constraining limits.

And here’s an example of “Hello World” in {language2}:

```{language2}

{language2_hello_world}
```

You can see how easily readable and maintainable {language2} is over {language1}. Its syntax is just as elegant as {language1}, but there’s no magic involved. Everything that I need to know is right there, ready to be understood in an easy-to-digest fashion. There’s no fighting with the language here, just me working with my trusty new tool.

Always use the best tool for the job. That’s why I have chosen to use {language2} for all my obscure side-projects. It will likely not have any technical flaws whatsoever, nor will its opinions ever turn out to be wrong. And, in the rare case that {language2} disappoints me…well, there’s always {language3}…
